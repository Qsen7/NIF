    internal class BinarySearchTree
    {
        private Node root;
        public void Insert(int value)
        {
            root = InsertRec(root,value);
        }
        private Node InsertRec(Node node, int value)
        {
            if (node == null)
                return new Node(value);

            if (value < node.Value)
                node.Left = InsertRec(node.Left, value);

            else if (value > node.Value)
                node.Right = InsertRec(node.Right, value);

            else
                Console.WriteLine($"Duplicate value{value}");
            return node;
        }
        public bool Search(int value)
        {
            return SearchRec(root, value);
        }
        private bool SearchRec(Node node, int value)
        {
            if(root == null) return false;

            if(value==node.Value) return true;

            else if(value < node.Value)
                return SearchRec(node.Left, value);
            
            else
                return SearchRec(node.Right,value);
        }


        public void InOrderTraversal()
        {
            InOrderRec(root);
            Console.WriteLine();
        }

        private void InOrderRec(Node node)
        {
            if(node != null)
            {
                InOrderRec(node.Left);
                Console.WriteLine(node.Value+" ");
                InOrderRec(node.Right);
            }
        }
    }

        internal class Node
    {
        public int Value;
        public Node Left;
        public Node Right;

        public Node(int value) {
            Value = value;
            Left = null;
            Right = null;
        }
    }

        internal class Program
    {
        static void Main(string[] args)
        {
            BinarySearchTree bst=new BinarySearchTree();
            Console.WriteLine("Vyvedi chisla");
            string input=Console.ReadLine();
            string[] parts=input.Split(' ');
            foreach(string part in parts)
            {
                bst.Insert(int.Parse(part));
            }

            bst.InOrderTraversal(); 
        }
    }
---------------------------------------------------------------------------
    Добавя height, ротации, баланс, автоматична балансировка
    public class Node
    {
        public int Value { get; set; }
        public Node Left { get; set; }
        public Node Right { get; set; }
        public int Height { get; set; }

        public Node(int value)
        {
            Value = value;
            Height = 1;
        }
    }

    public class BinarySearchTree
    {
        private Node root;


        public void Insert(int value)
        {
            root = Insert(root, value);
        }


        private Node Insert(Node node, int value)
        {
            if (node == null)
                return new Node(value);

            if (value < node.Value)
                node.Left = Insert(node.Left, value);
            else if (value > node.Value)
                node.Right = Insert(node.Right, value);
            else
                return node; // без дублиране


            node.Height = 1 + Math.Max(GetHeight(node.Left), GetHeight(node.Right));


            int balance = GetBalance(node);


            if (balance > 1 && value < node.Left.Value)
                return RotateRight(node);


            if (balance < -1 && value > node.Right.Value)
                return RotateLeft(node);


            if (balance > 1 && value > node.Left.Value)
            {
                node.Left = RotateLeft(node.Left);
                return RotateRight(node);
            }


            if (balance < -1 && value < node.Right.Value)
            {
                node.Right = RotateRight(node.Right);
                return RotateLeft(node);
            }

            return node;
        }

        private int GetHeight(Node node)
        {
            if (node != null)
            {
                return node.Height;
            }
            else
            {
                return 0;
            }
        }

        private int GetBalance(Node node)
        {
            if (node == null)
            {
                return 0;
            }
            else
            {
                return GetHeight(node.Left) - GetHeight(node.Right);
            }
        }

        private Node RotateRight(Node y)
        {
            Node x = y.Left;
            Node T2 = x.Right;

            x.Right = y;
            y.Left = T2;

            y.Height = 1 + Math.Max(GetHeight(y.Left), GetHeight(y.Right));
            x.Height = 1 + Math.Max(GetHeight(x.Left), GetHeight(x.Right));

            return x;
        }

        private Node RotateLeft(Node x)
        {
            Node y = x.Right;
            Node T2 = y.Left;

            y.Left = x;
            x.Right = T2;

            x.Height = 1 + Math.Max(GetHeight(x.Left), GetHeight(x.Right));
            y.Height = 1 + Math.Max(GetHeight(y.Left), GetHeight(y.Right));

            return y;
        }

        public void InOrder()
        {
            InOrder(root);
            Console.WriteLine();
        }

        private void InOrder(Node node)
        {
            if (node != null)
            {
                InOrder(node.Left);
                Console.Write(node.Value + " ");
                InOrder(node.Right);
            }
        }
    }

        static void Main(string[] args)
        {
            BinarySearchTree tree = new BinarySearchTree();

            tree.Insert(10);
            tree.Insert(20);
            tree.Insert(30);
            tree.Insert(40);
            tree.Insert(50);

            tree.Insert(25);

            Console.WriteLine("InOrder traversal (сортиран изход):");
            tree.InOrder();
        }
